#!/usr/bin/env bash


# this is my attempted rewrite of chatgpt's parallelization of my pt2 script


# setup some vars
# for single-line puzzles, this is so i can test multiple examples using this:
# while read -r puzzle; do ./pt2 "$puzzle"; done < example2
if [[ -z "$1" ]]
    then read -r puzzle
    else puzzle="$1"
fi
MAX_JOBS=6
shopt -s nullglob   # used for reading temp files at the end in case there were none
export TMPDIR=/dev/shm  # this is for my WSL instance where /tmp is disk-based instead of ram
TEMP_DIR="$(mktemp -d)"
trap 'rm -rf "$TEMP_DIR"' EXIT   # cleanup the temp directory when the script exits
grandtotal=0
declare -A shellpids    # used for the concurency gate

# this is the part that you need to develop as it all depends on the puzzle and script design. 
# Some puzzles you may want a worker per line or however it works out. Here i've chosen to
# only spawn workers for each major chunk and leave the subdivision to regular processing just
# so that i can get a handle on the concept. this puzzle doesnt need it, it's just for learning.

# create a recursive function that processes each chunk
processchunk() {

    local chunk="$1"
    local chunktotal=0
    local depth="${2:-0}"

    # loop over each marker inside the current chunk
    while [[ "$chunk" =~ ^([^\(]*)\(([0-9]+)x([0-9]+)\)(.*)$ ]]; do

        # before = ${BASH_REMATCH[1]}
        # length = ${BASH_REMATCH[2]}
        # loops  = ${BASH_REMATCH[3]}
        # after  = ${BASH_REMATCH[4]}

        # first setup the temp vars we'll need
        local matches=("${BASH_REMATCH[@]}")
        local stringtorepeat="${matches[4]::${matches[2]}}"
        local afterrepeat="${matches[4]:${matches[2]}}"
        
        # just add the length of anything before the marker
        ((chunktotal+=${#matches[1]}))

        # process the chunk 
        if (( depth == 0 )); then
            # only spawn subshells for main chunks
            local fileout="$TEMP_DIR/job_$((job_id++)).out"
            (   local inner="${ processchunk "$stringtorepeat" 1; }"
                echo $(( "${matches[3]}" * inner )) > "$fileout"
            ) &

            # Concurrency gate
            shellpids[$!]=1     # this has to be the very next command after the subshell spawn
            while (( ${#shellpids[@]} >= MAX_JOBS )); do

                wait -n -p doneshell ${!shellpids[*]}
                unset "shellpids[$doneshell]"
            done

            # Aternative concurrency gate at the cost of time/forking
            # if (( $(jobs -pr | wc -l) >= MAX_JOBS )); then
            #     wait -n     # wait for a worker to finish
            # fi
        else
            # add its length to the running total
            local stringlen="${ processchunk "$stringtorepeat" 1; }"
            (( chunktotal += ( ${matches[3]} * stringlen ) ))
        fi

        # modify the chunk with whats left
        chunk="$afterrepeat"
    done

    # add in any remaining bits and output the chunk total
    ((chunktotal+=${#chunk}))
    echo "$chunktotal"
}

# kick off the process with the puzzle input
(( grandtotal += ${ processchunk "$puzzle"; } ))

# wait until all subshells have finished processing
wait

# add in the totals from any subshells
for file in $TEMP_DIR/*; do
    (( grandtotal += $(<"$file") ))
done

echo "Length: $grandtotal"
