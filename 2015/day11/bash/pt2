#!/usr/bin/env bash

# this is the exact same code from pt1 as the instructions were just 'do it again'
# only copied the file for visual completeness

# read puzzle from stdin
read -r puzzle

# setup some vars
declare -A letnum numlet
for letter in {a..z}; do
    letnum[$letter]=$((++num))
    numlet[$num]=$letter
done

# create a function to validate a password
checkpw () {

    local pw="$1"
    local len="${#pw}"
    local validrules=0
    local i j

    # Passwords may not contain the letters i, o, or l
    [[ "$pw" =~ [iol] ]] && return 1
    ((validrules++))

    # Passwords must include one increasing straight of at least three letters
    for (( i=0; i<len-2; i++ )); do

        local straight="${pw:i:3}"
        local si="${straight::1}"
        [[ "$si" =~ ^[yz]$ ]] && continue

        stcheck="${numlet[$(( ${letnum[$si]}+1 ))]}${numlet[$(( ${letnum[$si]}+2 ))]}"
        if [[ "${straight:1}" == "$stcheck" ]]; then

            ((validrules++))
            break
        fi
    done

    # Passwords must contain at least two different, non-overlapping pairs of letters
    for (( i=0; i<len-3; i++ )); do
        if [[ "${pw:i:1}" == "${pw:i+1:1}" ]]; then
            # if we find the first pair, look for a second
            for (( j=i+2; j<len-1; j++ )); do
                if  [[ "${pw:j:1}" == "${pw:j+1:1}" ]] && \
                    [[ "${pw:i:2}" != "${pw:j:2}" ]]; then

                    ((validrules++))
                    break 2
                fi
            done
        fi
    done

    [[ $validrules -eq 3 ]] && return 0
    return 1
}

# create a function to increase a string by 1
increasepw () {

    local pw="$1"
    local inc="$2"
    local len="${#pw}"
    local i next

    # work backwards along the pw
    for (( i=len-1; i>=0; i-- )); do

        # get the next letter, as long as its not invalid
        (( next = ( ${letnum[${pw:i:1}]}+1 ) > 26 ? 1 : (${letnum[${pw:i:1}]}+1) ))
        next="${numlet[$next]}"
        while [[ "$next" =~ [iol] ]]; do
    
            (( next = ( ${letnum[$next]}+1 ) > 26 ? 1 : (${letnum[$next]}+1) ))
            next="${numlet[$next]}"
        done

        # modify the pw and stop if we didnt loop around
        pw="${pw:0:i}$next${pw:i+1}"
        [[ "$next" != "a" ]] && break
    done

    # set the puzzle to the new pw
    puzzle="$pw"
}

# now we just repeat the process until we eventually find the next pw
loops=0
increasepw "$puzzle"
while (! checkpw "$puzzle"); do
    increasepw "$puzzle"

    if (( $((++loops)) % 10000 == 0 )); then
        echo "$loops loops"
    fi
done

echo "Next valid password: $puzzle"