#!/usr/bin/env bash

# generated by Google Gemini via explicit layout instructions. This was simply to test if the idea i had was easier and/or faster than the streamer i was watching.
# 
# i'd like you to write a bash script. it will process standardin  line by line and return a total.
# what we know: each line will consist of a series of digits from 1-9.  
# what we want to do for each line: {recursively loop over each line until we find the biggest set of 12 digits by doing the following: {temporarily substring the line by moving the last 11 digits to a temp var (endline). then starting from 9 and working down to 1, use regex to search the remaining string for the highest available digit and use a capture group to catch all the digits *after* it (this will remove all the data before and the target digit). append the found digit to the end of a var (banktotal) that will be stored for the entire line. repeat that process, using the capture group from the regex as the new substring to search, but also move one of the digits from 'endline' and append it to the substring, that way it accounts for the shrinking number of digits needed to complete the puzzle. if the remaining length of the substring to search is equal to the number of digits remaining to complete, dont bother searching and just append those to  'banktotal'} 
# when each line is done, add the banktotal to an accumulator and echo that accumulator total at the end of the script.


# Initialize the grand total accumulator
accumulator=0

# Process Standard Input line by line
while read -r line; do

    # 1. Setup variables for this line
    len=${#line}
    
    # "temporarily substring the line by moving the last 1 digits to a temp var (endline)"
    # We calculate the split point: Total Length - 1
    split_index=$((len - 1))
    
    # search_string is the beginning of the line
    search_string="${line:0:split_index}"
    # endline is the reserve (last 1 digits)
    endline="${line:split_index}"
    
    banktotal=""
    
    # We need to find 2 digits total
    for (( i=0; i<2; i++ )); do
        digits_remaining=$((2 - i))
        
        # Optimization: Check if Total Available (search buffer + endline reserve)
        # equals the number of digits we still need. If so, we MUST take all of them.
        total_available=$(( ${#search_string} + ${#endline} ))
        
        if [[ $total_available -eq $digits_remaining ]]; then
            banktotal+="${search_string}${endline}"
            break
        fi

        # "starting from 9 and working down to 1"
        for (( digit=9; digit>=1; digit-- )); do
            # "use regex to search... capture group to catch all the digits *after* it"
            # Regex explanation: $digit(.*) looks for the digit and captures the suffix in group 1
            if [[ "$search_string" =~ $digit(.*) ]]; then
                
                # Append found digit to banktotal
                banktotal+="$digit"
                
                # "remove all the data before [the target digit]"
                # The capture group (BASH_REMATCH[1]) becomes the new search string
                search_string="${BASH_REMATCH[1]}"
                
                # "move one of the digits from 'endline' and append it to the substring"
                if [[ -n "$endline" ]]; then
                    next_char="${endline:0:1}"
                    search_string+="$next_char"
                    # Remove that char from endline
                    endline="${endline:1}"
                fi
                
                # Break the inner loop (9-1) to start the next digit search
                break
            fi
        done
    done

    # Add the banktotal for this line to the grand accumulator
    # We use 10# to force base-10 interpretation (prevents octal errors if string starts with 0, 
    # though prompt says digits are 1-9)
    (( accumulator += 10#$banktotal ))

done

# Echo the final total
echo "$accumulator"